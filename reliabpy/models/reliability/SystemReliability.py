# -*- coding: utf-8 -*-
"""
Created on Fri Mar  5 10:48:25 2021

@author: Felipe Giro

SYSTEM RELIABILITY
==================

Use Dynamic Bayesian Network to compute the probability of failure of a 
offshore wind turbine composed by 3 zones: atmosphecric, splash + submerged,
scour + foudation.

TODO list:
    - Comment the functions
    - Verify and validate
    - Implement pth criteria (be cafeful that it is the system level, not 
                              component)
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
from scipy.io import loadmat

#%% Functions
def comp_k_out_of_n(pf, k):
    '''
    COMPUTE PROBABILITY OF FAILURE OF THE SYSTEM RELIABILITY
    ========================================================
    
    The system is good if and only if at least K of its n components are good.
    
    => Model assumptions:
        1. Components and the system are 2-state (eg, good or bad)
        2. Component states are statiscally independent
        3. The system is good if and only if at least k of its n components 
           are good
    
    Source: IEEE TRANSACTIONS ON RELIABILITY, VOL. R-33, NO. 4, OCTOBER 1984
            page 321, R.E. Barlow and K.D. Heidtmann
    
    Parameters
    ----------
    pf : array-like
        the probability of failure of each element
    k : integer
        the number of components necessary to make the system work
    '''
    
    pf = np.array(pf)
    n = pf.size
    
    # in case of no element
    if n == 0:
        return np.nan
    
    # n = len(pf)
    # k = ncomp-1
    PF_sys = np.zeros(1)
    nk = n-k
    m = k+1
    A = np.zeros(m+1)
    A [1] = 1
    L = 1
    for j in range(1,n+1):
        h = j + 1
        Rel = 1-pf[j-1]
        if nk < j:
            L = h - nk
        if k < j:
            A[m] = A[m] + A[k]*Rel
            h = k
        for i in range(h, L-1, -1):
            A[i] = A[i] + (A[i-1]-A[i])*Rel
    PF_sys = 1-A[m]
    return PF_sys   

def _PoD(a, X0, b):
    return 1.0 - (1.0/(1.0 + (a/X0)**b))

#%% Class for system reliability
class SysReliab:
    def __init__(self,
                 lifetime     = 20,
                 comp_names   = ['atm01', 'atm02', 'atm03', 'atm04',
                                 'sub01', 'sub02', 'sub03', 'sub04',
                                 'scr01', 'scr02', 'scr03', 'scr04'],
                 KoutN_params = {'atm' : 2, 'sub' : 2, 'scr' : 2},
                 cost_dict    = {'cC' : 5     , # inspection campaign
                                 'cI' : 1.0   , # component inspection
                                 'cR' : 10.0  , # component repair
                                 'cF' : 10000., # system failure
                                 'r'  : 0.02}  # discount rate
                 ):
        
        # count number of components for each zone
        n_comp_temp = []
        for n_comps in comp_names: # getting zones
            zone = n_comps[:3]
            n_comp_temp.append(zone)
        self.n_comps_zone = {'atm':0, 'sub':0, 'scr':0}
        
        unique, counts = np.unique(n_comp_temp, return_counts=True)
        for u, c in zip(unique, counts):
            self.n_comps_zone[u] = c
            
    
        self.lifetime     = lifetime
        self.comp_names   = comp_names
        self.KoutN_params = KoutN_params
        
        # General setting
        
        # Inspection
        # DNVGL-RP-C210_RBI - Section 11
        # Table 11-1 PoD curves for EC, MPI, ACFM
        self.insp_dict = {
            'good'  : {'X0':0.40, 'b':1.43},
            'normal': {'X0':0.45, 'b':0.90},
            'bad'   : {'X0':1.16, 'b':0.90}
            }
        
        # Costs
        # 2019 - Luque, Straub - Risk-based optimal inspection strategies for 
        # structural systems using dynamic Bayesian networks 
        # Table 4, case 1
        
        self.cost_dict = cost_dict
               
    def T_import(self, T_folderpaths):
        '''
        TRANSITION MATRIX IMPORT
        ========================
        
        Import the transition matrixes generated by the dictionary
        
        
        Parameters
        ----------
        T_folderpaths : dict
            dictionary with keys atm, sub and scr. where the values are the
            transition matrixex

        Returns
        -------
        None.

        '''
        MatLab_atm = loadmat(T_folderpaths['atm'])['dr_env'][0]
        MatLab_sub = loadmat(T_folderpaths['sub'])['dr_env'][0]
        MatLab_scr = loadmat(T_folderpaths['scr'])['dr_env'][0]
        
        self.dict_nstates = {
            'atm' : int(MatLab_atm['stat'][0]),
            'sub' : int(MatLab_sub['stat'][0]),
            'scr' : int(MatLab_scr['stat'][0])}
        self.dict_aint = {
            'atm' : MatLab_atm['aint'][0][0],
            'sub' : MatLab_sub['aint'][0][0],
            'scr' : MatLab_scr['aint'][0][0]}
        self.dict_T = {
            'atm' : MatLab_atm['T0'][0].toarray(),
            'sub' : MatLab_sub['T0'][0].toarray(),
            'scr' : MatLab_scr['T0'][0].toarray()}
        self.dict_b0 = {
            'atm' : MatLab_atm['b0'][0],
            'sub' : MatLab_sub['b0'][0],
            'scr' : MatLab_scr['b0'][0]}
        
        self.T_folderpaths = T_folderpaths
    
    def DBN_inference(self, insp_rules = {'delta_t': 5.0, # campagin interval
                                          'p_th'   : 1.0, # pf threshold
                                          'nI'     : 3  , # no. insp. components
                                          'dR'     : 0  }): # repair criteria)
        
        components = self.comp_names
        year_list  = np.linspace(1, self.lifetime, num=self.lifetime)
        campaigns = np.zeros(len(year_list), dtype=bool)
        
        # verifying the inspection policy
        if type(insp_rules) is np.ndarray:
            # pre stablished map
            do_heur = False
            
            inspec_map = insp_rules.copy()
            repair_map = np.zeros((self.lifetime, len(components)), dtype=bool)
            
            campaigns  = inspec_map.any(axis=1)
            extra_campaigns = np.zeros_like(campaigns, dtype=bool)
            
            self.p_th, p_th = None, None
            
        elif type(insp_rules) is dict:
            # heuristic rule
            do_heur = True
            
            delta_t = insp_rules['delta_t'] 
            p_th    = insp_rules['p_th'] 
            nI      = insp_rules['nI'] 
            # dR      = insp_rules['dR'] 
            
            self.p_th = p_th 
        
            # updating campaings
            campaigns[np.arange(delta_t, year_list[-1], delta_t, dtype=int)-1] = True
            extra_campaigns = np.zeros_like(campaigns, dtype=bool)
            
            inspec_map = np.zeros((self.lifetime, len(components)), dtype=bool)
            repair_map = np.zeros((self.lifetime, len(components)), dtype=bool)
        
        # DBN for each element
        
        # inspection definition per zone
        a_disc = np.diff(self.dict_aint['atm']/2) + self.dict_aint['atm'][:-1] # midpoint
        zone_PoD = {'atm' : np.tile(_PoD(a_disc, **self.insp_dict['normal']), 
                                      int(len(self.dict_T['atm'])/len(a_disc))),
                    'sub' : np.tile(_PoD(a_disc, **self.insp_dict['bad']), 
                                      int(len(self.dict_T['sub'])/len(a_disc))),
                    'scr' : None}
        
        years, pf_comps, b_comps, b_temp = list(), list(), list(), list()
        comp_zones = list()
        
        # computing initial belief for each component
        years.append(0)
        for component in components:
            zone = component[:3] # getting the first 3 letters
            comp_zones.append(zone)
            b0 = self.dict_b0[zone].copy()
            b_temp.append(b0)
            pf_comps.append(np.sum(b0.reshape((21,60))[:,-1])) # NOTE: states fixed
        b_comps  = [b_temp]
        pf_comps = [pf_comps]
        
        # initiliazation of maps
        comp_zones = np.array(comp_zones)
        
        # over inspections years (from 1)
        for year, campaign in zip(year_list, campaigns):
            years.append(year)
            
            # for one year, predict all components
            pf_temp, b_temp, pf_temp1, b_temp1 = list(), list(), list(), list()
            for component, b in zip(components, b_comps[-1]):
                zone = component[:3] # getting the first 3 letters
                b = np.dot(b, self.dict_T[zone])
                b_temp.append(b)
                pf_temp.append(np.sum(b.reshape((21,60))[:,-1])) # NOTE: states fixed
                
                # evaluating the threshold (propagating the second time)
                if p_th or p_th == 1:
                    b1 = np.dot(b, self.dict_T[zone])
                    b_temp1.append(b1)
                    pf_temp1.append(np.sum(b1.reshape((21,60))[:,-1])) # NOTE: states fixed
            
            # evaluating the system pf threshold
            if p_th:
                extra_campaign = self._comp_Y_sysreliab(np.array(pf_temp1))[-1] > p_th
                extra_campaigns[int(year)-1] = extra_campaign
            else:
                extra_campaign = False
            
            b_comps.append(b_temp)
            pf_comps.append(pf_temp)
            cdet_temp = np.zeros_like(components, dtype=bool)
            

            to_inspect = np.zeros_like(pf_temp, dtype=bool)
                
            # inspection fo every component
            if any([campaign, extra_campaign]):
                years.append(year + 0.0000001)
                
                # computing the number of "inspectable" components
                ncan = ((comp_zones == 'atm') | (comp_zones == 'sub')).sum()
                
                # Identifying the most critical components
                if do_heur:
                    comp_campaign = np.array(pf_temp[:ncan]).argsort()[::-1][:nI]     # ATTENTION gambiarra to exclude the scr
                    to_inspect[comp_campaign] = True
                else:
                    to_inspect = inspec_map[int(year-1), :]
                
                # update belief
                pf_temp, b_temp, cdet_temp = list(), list(), list()
                for component, b, inspect in zip(components, b_comps[-1], to_inspect):
                    zone = component[:3] # getting the first 3 letters
                    if inspect:
                        b_D  = b*(  zone_PoD[zone]) # detected
                        b_ND = b*(1-zone_PoD[zone]) # Not Detected
                        
                        # randomness in crack detection
                        crack_detected = bool(np.random.binomial(1, b_D.sum()))
                        if crack_detected: 
                            # Repair immediataly # b_ = b_D
                            b_ = self.dict_b0[zone]
                        else:
                            b_ = b_ND.copy()
                            
                        b_ /= b_.sum()
                        
                        cdet_temp.append(crack_detected)
                        b_temp.append(b_.copy())
                        pf_temp.append(np.sum(b_.reshape((21,60))[:,-1])) # NOTE: states fixed
                    else:
                        cdet_temp.append(False)
                        b_temp.append(b)
                        pf_temp.append(np.sum(b.reshape((21,60))[:,-1])) # NOTE: states fixed
                b_comps.append(b_temp)
                pf_comps.append(pf_temp)
            
            repair_map[int(year-1), :] = cdet_temp 
            inspec_map[int(year-1), :] = to_inspect
            
        self.repair_map = np.array(repair_map)
        self.campaigns = campaigns
        self.extra_campaigns = extra_campaigns
        self.inspec_map = np.array(inspec_map)
        self.year_list = year_list
        self.years = years
        self.pf_comps = np.array(pf_comps)
        
        self._comp_sysreliab()
        self._comp_costs()

    def save_results(self, savepath = 'data/example'):
        n_comps = len(self.comp_names)
        
        # Probability of Failure DataFrame
        df_pfs = pd.DataFrame(data    = self.pf_comps, 
                              index   = self.years,
                              columns = self.comp_names)
        df_pfs['atm'] = self.pf_atm
        df_pfs['sub'] = self.pf_sub
        df_pfs['scr'] = self.pf_scr
        df_pfs['sys'] = self.pf_sys
        
        # Probability of Failure plotting 
        figure, axes = plt.subplots(nrows=3, ncols=1, figsize=(6,6), 
                                    sharex=True)
        df_pfs.iloc[:, :n_comps].plot(title='Components Reliability', ax=axes[0],
                    kind='line', logy=False, grid=True, colormap='Paired', 
                    xlabel='time [years]', ylabel='Prob. Failure',
                    use_index=True, legend=False)
        
        df_pfs[['sys']].plot( # df_pfs[['atm', 'sub', 'scr', 'sys']].plot(
            title='System reliability', ax=axes[1], grid=False,
            xlabel='time [years]', ylabel='Prob. Failure',
            use_index=True, color='darkred', lw=2.5, legend=False)
        if self.p_th:
            axes[1].axhline(self.p_th, ls='--', color='m')
        # axes[1].legend(['Support structure'])
        
        # Inspection Map DataFrame
        df_InspecMap = pd.DataFrame(data    = self.inspec_map,
                                    index   = self.year_list,
                                    columns = self.comp_names)
        df_InspecMap['campaign'] = self.campaigns
        df_pfs.iloc[:, :n_comps][df_InspecMap].plot(kind='line', legend=False,  
                                               ax=axes[0], marker='D', 
                                               markersize=3, ls=None, color='k',
                                               use_index=True)
        
        # repair/detection map
        df_RepairMap = pd.DataFrame(data    = self.repair_map,
                                    index   = self.year_list,
                                    columns = self.comp_names)
        df_pfs.iloc[:, :n_comps][df_RepairMap].plot(kind='line', legend=False,  
                                               ax=axes[0], marker='D', 
                                               markersize=4, color='m',
                                               ls=None, grid=False, use_index=True)
        
        # costs
        df_Costs = pd.DataFrame({
            'CC':self.annual_CC, 'CI':self.annual_CI, 
            'CR':self.annual_CR, 'RF':self.annual_RF},
            index=self.year_list)
        df_Costs.loc[0] = 0
        df_Costs.sort_index(inplace=True)
        df_Costs.plot(kind='bar', title='Costs (total:{:.2f})'.format(self.CT), 
                      stacked=True, grid=False, ax=axes[2], legend=True,
                      xlabel='lifetime service [years]', ylabel='Cost')
        axes[2].legend(['Campaign', 'Inspection', 'Repair', 'Failure'])# , ncol=4, loc=8, bbox_to_anchor=(0.5, -1), fontsize='xx-large')
        
        # plot the campaing and extra campaigns markes
        for year, campaign, extra_campaign in zip(self.year_list, self.campaigns,  self.extra_campaigns):
            if campaign:
                axes[0].axvline(year, color='0.5', ls='--')
                axes[1].axvline(year, color='0.5', ls='--')
                axes[2].axvline(year, color='0.5', ls='--')
            if extra_campaign:
                axes[0].axvline(year, color='0.5', ls=':')
                axes[1].axvline(year, color='0.5', ls=':')
                axes[2].axvline(year, color='0.5', ls=':')
        
        # formating
        for ax in axes:
            # Rewrite the y labels
            # x_labels = ax.get_xticks()
            ax.xaxis.set_major_formatter(ticker.FormatStrFormatter('%0.0f'))
            ax.xaxis.set_major_locator(plt.MaxNLocator(11))
            ax.tick_params(axis='x', rotation=0)
        # y_labels = axes[0].get_yticks()
        axes[0].yaxis.set_major_formatter(ticker.FormatStrFormatter('%0.3f'))
        axes[1].yaxis.set_major_formatter(ticker.FormatStrFormatter('%0.0e'))
        axes[2].yaxis.set_major_formatter(ticker.FormatStrFormatter('%0.2f'))
        
        # saving figure and excel table
        plt.tight_layout()
        plt.savefig(savepath + '_pfsys.png')
        df_pfs.to_excel(savepath + '_pfsys.xlsx')
        df_InspecMap.to_excel(savepath + '_InspecMap.xlsx')
        df_RepairMap.to_excel(savepath + '_RepairMap.xlsx')
        df_Costs.to_excel(savepath + '_Costs.xlsx')
    
    def _comp_Y_sysreliab(self, pfs):
        i = [0, 
             self.n_comps_zone['atm'], 
             self.n_comps_zone['atm'] + self.n_comps_zone['sub'], 
             self.n_comps_zone['atm'] + self.n_comps_zone['sub'] + self.n_comps_zone['scr']]
        
        # compute the system reliability of one year
        pf_atm = comp_k_out_of_n(pfs[i[0]:i[1]], self.KoutN_params['atm'])
        pf_sub = comp_k_out_of_n(pfs[i[1]:i[2]], self.KoutN_params['sub'])
        pf_scr = comp_k_out_of_n(pfs[i[2]:i[3]], self.KoutN_params['scr'])
        
        pf_zones = np.array([pf_atm, pf_sub, pf_scr])
        pf_zones = pf_zones[~np.isnan(pf_zones)]
        pf_sys = comp_k_out_of_n((pf_zones), len(pf_zones))
        return pf_atm, pf_sub, pf_scr, pf_sys
    
    def _comp_sysreliab(self):
        # computing the system reliability
        pf_atm, pf_sub, pf_scr, pf_sys = list(), list(), list(), list()
        for year, pfs in zip(self.years, self.pf_comps):   
            pf_atm_Y, pf_sub_Y, pf_scr_Y, pf_sys_Y = self._comp_Y_sysreliab(pfs)
            pf_atm.append(pf_atm_Y)
            pf_sub.append(pf_sub_Y)
            pf_scr.append(pf_scr_Y)
            pf_sys.append(pf_sys_Y)
        
        self.pf_atm, self.pf_sub, self.pf_scr, self.pf_sys = pf_atm, pf_sub, pf_scr, pf_sys
        
    def _comp_costs(self):
        # discount factor
        y_t = (1-self.cost_dict['r'])**self.year_list 
        annual_pfsys = np.diff(self.pf_sys)
        annual_pfsys = annual_pfsys[np.diff(self.years)>0.1]
        
        self.annual_RF = self.cost_dict['cF']*(annual_pfsys*y_t)
        self.annual_CC = self.cost_dict['cC']*((self.campaigns+self.extra_campaigns)*y_t)
        self.annual_CI = self.cost_dict['cI']*(self.inspec_map.sum(axis=1)*y_t)
        self.annual_CR = self.cost_dict['cI']*(self.repair_map.sum(axis=1)*y_t)
        
        self.RF = self.annual_RF.sum()
        self.CC = self.annual_CC.sum()
        self.CI = self.annual_CI.sum()
        self.CR = self.annual_CR.sum()
        self.CT = self.CC + self.CI + self.CR + self.RF
        
#%% example 
if __name__ == '__main__':
    from time import time
    
    insp_map = pd.read_excel(
        'data/SysReliab__IN_InspecMap.xlsx', index_col=0).values
    
    # User input
    T_folderpaths = {'atm' : 'data/atm/dr_OUT.mat',
                     'sub' : 'data/sub/dr_OUT.mat',
                     'scr' : 'data/scr/dr_OUT.mat'}
    
    # Runnig system Reliability 
    k = 3
    OWT = SysReliab(
        lifetime     = 20,
        comp_names   = ['atm01', 'atm02', 'atm03', 'atm04',
                        'sub01', 'sub02', 'sub03', 'sub04',
                        'scr01', 'scr02', 'scr03', 'scr04'],
        KoutN_params = {'atm' : 2, 'sub' : 3, 'scr' : 3},
        cost_dict    = {'cC' : 5     , # inspection campaign
                        'cI' : 1.0   , # component inspection
                        'cR' : 10.0  , # component repair
                        'cF' : 10000., # system failure
                        'r'  : 0.02}   # discount rate
        
        #insp_rules   = {'delta_t' : 8   , # campaign interval
        #                'p_th'    : None, # pf threshold
        #                'nI'      : 3   , # no. insp. components
        #                'dR'      : 0   } # repair criteria
        )
    OWT.T_import(T_folderpaths)
    OWT.DBN_inference(insp_rules = insp_map
                      #insp_rules   = {'delta_t' : 8   , # campaign interval
                      #                'p_th'    : None, # pf threshold
                      #                'nI'      : 3   , # no. insp. components
                      #                'dR'      : 0   } # repair criteria
                      )
    OWT.save_results('data/SysReliab')
    
    print('- cost:', OWT.CC, OWT.CI, OWT.CR, OWT.RF, OWT.CT)
    
    # without any inspection policy : 
    #   CT 1out4 =    4.1501518288248
    #   CT 2out4 =  100.87890858168109
    #   CT 3out4 = 1000.1888579885284
    #   CT 4out4 = 4794.464573694547
    
